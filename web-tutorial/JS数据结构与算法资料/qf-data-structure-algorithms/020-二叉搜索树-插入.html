<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>020-二叉搜索树</title>
</head>

<body>
  <div>
    树是一种分层数据的抽象模型，是一种非顺序的数据结构。
  </div>
</body>
<script>
  const Compare = {
    less: -1,
    bigger: 1,
    equal: 0,
  }
  class Node {
    constructor(key) {
      this.key = key
      this.left = null
      this.right = null
    }
  }

  class BST {
    constructor() {
      this.root = null
    }

    insert (key) {
      if (this.root === null) {
        this.root = new Node(key)
      } else {
        this.insertNode(this.root, key)
      }
    }

    compareFn (a, b) {
      if (a === b) {
        return Compare.equal
      } else if (a < b) {
        return Compare.less
      } else {
        return Compare.bigger
      }
    }

    insertNode (node, key) {
      if (this.compareFn(key, node.key) === Compare.less) {
        if (node.left === null) {
          node.left = new Node(key)
        } else {
          this.insertNode(node.left, key)
        }
      } else {
        if (node.right === null) {
          node.right = new Node(key)
        } else {
          this.insertNode(node.right, key)
        }
      }
    }

    // 中序遍历：以从最小到最大的顺序访问所有节点。
    inOrderMap (cb) {
      this.inOrderMapNode(this.root, cb)
    }

    inOrderMapNode (node, cb) {
      if (node !== null) {
        // 先执行左侧值小的
        this.inOrderMapNode(node.left, cb)
        cb(node.key)
        // 再执行右侧值大的
        this.inOrderMapNode(node.right, cb)
      }
    }

    // 先序遍历：以优先于后代节点的顺序访问每个节点。
    preOrderMap (cb) {
      this.preOrderMapNode(this.root, cb)
    }

    preOrderMapNode (node, cb) {
      if (node !== null) {
        // 先执行根节点
        cb(node.key)
        this.preOrderMapNode(node.left, cb)
        this.preOrderMapNode(node.right, cb)
      }
    }

    // 后序遍历：先访问节点的后代节点，再访问节点本身。
    postOrderMap (cb) {
      this.postOrderMapNode(this.root, cb)
    }

    postOrderMapNode (node, cb) {
      if (node !== null) {
        this.postOrderMapNode(node.left, cb)
        this.postOrderMapNode(node.right, cb)
        // 最后执行根节点
        cb(node.key)
      }
    }
  }

  const myTree = new BST()
  myTree.insert(100)
  myTree.insert(80)
  myTree.insert(70)
  myTree.insert(90)
  myTree.insert(110)
  myTree.postOrderMap((value) => {
    console.log(value)
  })
</script>

</html>